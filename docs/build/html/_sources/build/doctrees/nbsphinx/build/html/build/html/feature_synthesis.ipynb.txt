{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "d07cf18d",
   "metadata": {},
   "source": [
    "# üß© FeatureSynthesis\n",
    "\n",
    "The `FeatureSynthesis` class is the main interface for generating new symbolic features using **Evolutionary Feature Synthesis (EFS)**.\n",
    "\n",
    "It acts as a scikit-learn-compatible transformer (`fit`, `transform`, `fit_transform`) that automatically evolves **interpretable mathematical expressions** from your input features and selects the best ones based on predictive performance.\n",
    "\n",
    "---\n",
    "\n",
    "## üîß Parameters\n",
    "\n",
    "| Argument                  | Type                      | Description |\n",
    "|---------------------------|---------------------------|-------------|\n",
    "| `num_features`            | `int`                     | Number of features to return after synthesis and selection |\n",
    "| `population_size`         | `int`                     | Number of symbolic programs in each generation |\n",
    "| `max_generations`         | `int`                     | Maximum number of generations to run |\n",
    "| `tournament_size`         | `int`                     | Size of the tournament for parent selection |\n",
    "| `crossover_proba`         | `float` (0‚Äì1)             | Probability of crossover between selected parents |\n",
    "| `parsimony_coefficient`   | `float`                   | Controls how strongly large programs are penalized |\n",
    "| `adaptive_parsimony`      | `bool`                    | Whether to adapt parsimony over generations based on average program size |\n",
    "| `early_termination_iters` | `int`                     | Stop early if no improvement after this many generations |\n",
    "| `functions`               | `List[str]` or `List[SymbolicFunction]` | Functions used to construct expressions (e.g., `\"add\"`, `\"log\"`) |\n",
    "| `custom_functions`        | `List[SymbolicFunction]`  | User-defined symbolic functions (optional) |\n",
    "| `fitness_function`        | `str` or `Callable`       | Fitness metric to optimize (`\"pearson\"`, `\"r2\"`, etc.) |\n",
    "| `return_all_features`     | `bool`                    | Whether to return original features along with synthesized ones |\n",
    "| `n_jobs`                  | `int`                     | Number of CPU cores to use (`-1` = all cores) |\n",
    "| `pbar`                    | `bool`                    | Whether to show a progress bar during evolution |\n",
    "| `verbose`                 | `bool`                    | Print generation progress and best programs |\n",
    "\n",
    "---\n",
    "\n",
    "## ‚öôÔ∏è How it Works\n",
    "\n",
    "1. **Initialization**:\n",
    "   - A random population of symbolic programs is created from your input features and available symbolic functions.\n",
    "\n",
    "2. **Evolution**:\n",
    "   - Over multiple generations:\n",
    "    - Each program is evaluated using a fitness function (e.g., correlation with the target)\n",
    "    - Top programs are selected via tournament selection\n",
    "    - Offspring are generated via crossover and mutation\n",
    "\n",
    "3. **Selection (mRMR)**:\n",
    "   - After evolution, the best programs are filtered using Maximum Relevance Minimum Redundancy (mRMR) to ensure that selected features are:\n",
    "     - Highly predictive\n",
    "     - Minimally redundant\n",
    "\n",
    "4. **Transformation**:\n",
    "   - The best programs are used to transform data in `.transform()` or `.fit_transform()`.\n",
    "\n",
    "---\n",
    "\n",
    "## üß™ Methods\n",
    "\n",
    "### `.fit(X, y)`\n",
    "\n",
    "Train the feature synthesizer on your dataset. Evolves symbolic expressions predictive of the target `y`.\n",
    "\n",
    "### `.transform(X)`\n",
    "\n",
    "Apply the top symbolic formulas to new input data `X`, returning new synthesized features.\n",
    "\n",
    "### `.fit_transform(X, y)`\n",
    "\n",
    "Convenient method to run `.fit()` and `.transform()` in one step.\n",
    "\n",
    "### `.get_feature_info()`\n",
    "\n",
    "Returns a pandas.DataFrame showing:\n",
    "\n",
    "- **name**: Auto-generated feature name\n",
    "- **formula**: The final simplified symbolic formula\n",
    "- **raw_formula**: The original (possibly unsimplified) formula\n",
    "- **fitness**: The final score used for selection\n",
    "\n",
    "### `.plot_history()`\n",
    "\n",
    "Generates a line plot of:\n",
    "\n",
    "- Best fitness per generation\n",
    "- Parsimony coefficient (if adaptive)\n",
    "- Early stopping indicator\n",
    "\n",
    "---\n",
    "\n",
    "## üìù Example\n",
    "\n",
    "```python\n",
    "from featuristic import FeatureSynthesis\n",
    "from featuristic.datasets import fetch_wine_dataset\n",
    "\n",
    "X, y = fetch_wine_dataset()\n",
    "\n",
    "efs = FeatureSynthesis(num_features=5, max_generations=30)\n",
    "X_new = efs.fit_transform(X, y)\n",
    "\n",
    "efs.get_feature_info()\n",
    "efs.plot_history()\n",
    "```\n",
    "\n",
    "---\n",
    "\n",
    "## üß† Tip\n",
    "\n",
    "- Set `adaptive_parsimony=True` to automatically discourage overly complex features as the search progresses.\n",
    "- Want transparency? Set `verbose=True` to print the best symbolic formula every generation.\n",
    "- Need to restrict operations? Use `functions=[\"add\", \"log\", \"sqrt\"]` to limit what expressions are allowed.\n"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
